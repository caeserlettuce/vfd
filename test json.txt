{"brightness": 4, "listing": [[22, 17], [24, 15], [23, 2], [22, 11], [23, 16], [24, 7], [23, 15], [29, 11], [29, 14], [28, 15], [25, 14], [29, 17], [22, 14], [29, 16], [25, 11], [24, 14], [24, 13], [24, 16], [29, 15], [23, 8], [24, 12], [24, 17], [25, 17], [25, 16], [22, 10], [24, 5], [25, 10], [23, 3], [22, 16], [28, 16], [25, 13], [22, 13]]}





{"brightness": 4, "listing": [[19, 13], [20, 13], [21, 13], [22, 13], [23, 13], [19, 12], [20, 12], [21, 12], [22, 12], [19, 11], [20, 11], [23, 11], [19, 10], [23, 10], [20, 14], [23, 14], [19, 15], [23, 15], [20, 17]]}


{"brightness": 4, "listing": [[0, 8, 32, 0], [0, 8, 16, 0], [0, 8, 8, 0], [0, 8, 4, 0], [0, 8, 2, 0], [0, 16, 32, 0], [0, 16, 16, 0], [0, 16, 8, 0], [0, 16, 4, 0], [0, 32, 32, 0], [0, 32, 16, 0], [0, 32, 2, 0], [0, 64, 32, 0], [0, 64, 2, 0], [0, 4, 16, 0], [0, 4, 2, 0], [0, 2, 32, 0], [0, 2, 2, 0], [0, 0, 144, 0]]}




    {"brightness": 4, "listing": [[8, 0, 64, 0], [8, 0, 32, 0], [8, 0, 16, 0], [8, 0, 8, 0], [8, 0, 4, 0], [8, 0, 2, 0], [8, 0, 1, 0], [8, 0, 0, 128], [8, 0, 0, 64], [16, 0, 32, 0], [16, 0, 16, 0], [16, 0, 8, 0], [16, 0, 4, 0], [16, 0, 2, 0], [16, 0, 1, 0], [16, 0, 0, 128], [16, 0, 0, 64], [4, 0, 32, 0], [4, 0, 16, 0], [4, 0, 8, 0], [4, 0, 4, 0], [4, 0, 2, 0], [4, 0, 1, 0], [4, 0, 0, 128], [4, 0, 0, 64], [32, 0, 2, 0], [32, 0, 1, 0], [64, 0, 2, 0], [0, 128, 64, 0], [0, 128, 32, 0], [0, 128, 16, 0], [0, 128, 8, 0], [0, 128, 4, 0], [0, 128, 2, 0], [0, 128, 1, 0], [0, 128, 0, 128], [0, 128, 0, 64], [0, 128, 0, 32], [0, 128, 0, 16], [0, 128, 0, 8], [0, 64, 64, 0], [0, 64, 32, 0], [0, 64, 16, 0], [0, 64, 8, 0], [0, 64, 4, 0], [0, 64, 2, 0], [0, 64, 1, 0], [0, 64, 0, 128], [0, 64, 0, 64], [0, 64, 0, 32], [0, 64, 0, 16], [0, 64, 0, 8], [0, 32, 64, 0], [0, 32, 32, 0], [0, 32, 16, 0], [0, 32, 8, 0], [0, 32, 4, 0], [0, 32, 2, 0], [0, 32, 1, 0], [0, 32, 0, 128], [0, 32, 0, 64], [0, 32, 0, 32], [0, 32, 0, 16], [0, 32, 0, 8], [0, 16, 64, 0], [0, 16, 32, 0], [0, 16, 16, 0], [0, 16, 8, 0], [0, 16, 4, 0], [0, 16, 2, 0], [0, 16, 1, 0], [0, 16, 0, 128], [0, 16, 0, 64], [0, 16, 0, 32], [0, 16, 0, 16], [0, 16, 0, 8], [0, 8, 64, 0], [0, 8, 32, 0], [0, 8, 16, 0], [0, 8, 8, 0], [0, 8, 4, 0], [0, 8, 2, 0], [0, 8, 1, 0], [0, 8, 0, 128], [0, 8, 0, 64], [0, 8, 0, 32], [0, 8, 0, 16], [0, 8, 0, 8], [0, 4, 64, 0], [0, 4, 32, 0], [0, 4, 16, 0], [0, 4, 8, 0], [0, 4, 4, 0], [0, 4, 2, 0], [0, 4, 1, 0], [0, 4, 0, 128], [0, 4, 0, 64], [0, 4, 0, 32], [0, 4, 0, 16], [0, 4, 0, 8], [0, 2, 64, 0], [0, 2, 32, 0], [0, 2, 16, 0], [0, 2, 8, 0], [0, 2, 4, 0], [0, 2, 2, 0], [0, 2, 1, 0], [0, 2, 0, 128], [0, 2, 0, 64], [0, 2, 0, 32], [0, 2, 0, 16], [0, 2, 0, 8], [0, 1, 64, 0], [0, 1, 32, 0], [0, 1, 16, 0], [0, 1, 8, 0], [0, 1, 4, 0], [0, 1, 2, 0], [0, 1, 1, 0], [0, 1, 0, 128], [0, 1, 0, 64], [0, 1, 0, 32], [0, 1, 0, 16], [0, 1, 0, 8], [0, 0, 192, 0], [0, 0, 160, 0], [0, 0, 144, 0], [0, 0, 136, 0], [0, 0, 132, 0], [0, 0, 130, 0], [0, 0, 129, 0], [0, 0, 128, 128], [0, 0, 128, 64], [0, 0, 128, 32], [0, 0, 128, 16], [0, 0, 128, 8], [1, 0, 64, 0], [1, 0, 32, 0], [1, 0, 16, 0], [1, 0, 8, 0], [1, 0, 4, 0], [1, 0, 2, 0], [1, 0, 1, 0], [1, 0, 0, 128], [1, 0, 0, 64], [1, 0, 0, 32], [1, 0, 0, 16], [2, 0, 64, 0], [2, 0, 32, 0], [2, 0, 16, 0], [2, 0, 8, 0], [2, 0, 4, 0], [2, 0, 2, 0], [2, 0, 1, 0], [2, 0, 0, 128], [2, 0, 0, 64], [2, 0, 0, 16]]}




[B00000000,B00000000,B00000000,B00000000]

[B00000000,B00000000,B11000000,B00000000]


// arduino json librarbar
#include <ArduinoJson.h>





// param variables
bool debug_messages = true;
int chip_outputs = 32;        // how many total outputs on your shift register(s)
int display_segments = 157;   // how many segments your display has
float brightness_steps = 20;  // max brightness integer. despite it being a float, don't make it a decimal.
float tick_speed = 0.1;       // ms between ticks
float pwm_tick_speed = 1;     // ms between pwm ticks.don't make this a decimal.
float interlace_speed = 2;    // amount of times a segment will be shown before moving on to the next segment




// do not touch variables
int registers = chip_outputs / 8;
int json_size = int(display_segments * 81.528); // calculate how big the json needs to be based on how many segments there are
DynamicJsonDocument doct(json_size);
JsonArray addresses = doct.as<JsonArray>(); // json element
bool reset_state = true;
float brightness_tm = 0;
int pwm_index = 0;
float duty = 0;
float interlaceRatio = 0;
float interlace_index = 0;
int data_index = 0;
float tpc = round(1000 / tick_speed);
float pwm_tpc = round((tpc / tick_speed) / pwm_tick_speed);
int tick_index = 0;



void setup() {
  // put your setup code here, to run once:

  Serial.begin(9600);

  pinMode(13, OUTPUT);

}

void debug(String message) {
  if (debug_messages == true) {
    Serial.print("\n DBG: " + message);  
  }
}


void send_data(byte data) {

  Serial.print(data);
  
}



void loop() {
  // put your main code here, to run repeatedly:
//Serial.print("yo");/
  
//
//  delay(1000);
//  digitalWrite(13, HIGH);
//  delay(1000);
//  digitalWrite(13, LOW);

//  Serial.println(reset_state);/
//  Serial.print(1 == true);/

// right now the pwm speed is 1ms
// say i want the tick speed to be 0.1ms
// but keep the pwm speed at 1ms
// 1 "cycle" as im gonna call it is 1 second


  if (reset_state == false) {

    // DISPLAY OFF
    digitalWrite(13, LOW);

    if ( int(interlaceRatio) != 0 && pwm_index % int(interlaceRatio) == 0 && reset_state == false) {

      // DISPLAY ON
      digitalWrite(13, HIGH);

      interlace_index += 1;
      
      
      if ( round(interlace_index) % round(interlace_speed) == 0 && reset_state == false) {
        // jaja data time

//        Serial.print(data_in/dex);
        
        data_index += 1;
        if ( data_index >= doct.size()) {
          data_index = 0;
        }        
      }
    }
     
  }


  if ( tick_index % round(pwm_tpc)) {
    pwm_index += 1;
//   / Serial.println("pwm index");
  }
  



  String read_string = "";
  while (Serial.available()) {
//    Serial.print("poo");/
    
//    delay(3);  //de/lay to allow buffer to fill /
    if (Serial.available() > 0) {
      char c = Serial.read();  //gets one byte from serial buffer
      read_string += c; //makes the string readString
    }

    if (Serial.available() == 1) {
      DynamicJsonDocument doc(json_size);
      String input = read_string;
      deserializeJson(doc, input);
      JsonObject obj = doc.as<JsonObject>(); // json element
       
      bool contains_brightness = obj.containsKey("brightness");
      bool contains_listing = obj.containsKey("listing");

      if (contains_brightness == true and contains_listing == true) {
        brightness_tm = obj["brightness"].as<float>();
//        Serial.print(obj["brightness/"].as<float>());
            
        int size = obj["listing"].size();

        // INPUT CONFIRMED, RUN ONCE STUFF HAPPENS HERE!
 
        doct.clear();
  
        for (int i = 0; i < size; ++i) {    // for all addresses in address listing
          int size_two = obj["listing"][i].size();
          addresses.createNestedArray();
          for (int e = 0; e < size_two; ++e) {    // for all bytes in address listing
            doct[i].add(obj["listing"][i][e]);
          }
        }
        pwm_index = 0;
        interlace_index = 0;
        data_index = 0;
        reset_state = false;
    
        debug("jaja");

        duty = 0;
        if (brightness_tm != 0) {
          duty = round ((brightness_tm / brightness_steps) * pwm_tpc );
        }

        interlaceRatio = 0;
        if(duty != 0){
          interlaceRatio = pwm_tpc / duty; // the ratio between time that the display is off vs time the display is on
        }

        
//        Serial.println();
//        Serial.println(duty);
//        Serial.println(interlaceRatio);
      }
    }
    
  }
    
  tick_index += 1;
  if (tick_index >= 10000 / tick_speed) {
    tick_index = 0;
    Serial.println("tick index reset!");
  }
  delay(tick_speed);
  


//
//  if (doct.memoryUsage() > json_size * 4) {
//    // clear it up!
//    doct.garbageCollect();
//  }
  
}

